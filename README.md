# AchemDB

AchemDB is a Go library that implements an **artificial chemistry database** - a novel approach to data processing inspired by chemical reactions. Instead of traditional database queries, data entities (molecules) interact through reactions that transform them based on patterns, rates, and environmental conditions.

## Overview

In AchemDB, data is represented as **molecules** that belong to different **species**. These molecules can undergo **reactions** that:

- Transform molecules into new species
- Update molecule properties (energy, stability, payload)
- Consume or create molecules
- React based on probabilistic rates and environmental context

This model is particularly well-suited for:

- Event processing and pattern detection
- Security alert systems
- Anomaly detection
- Complex state machines
- Reactive data pipelines

## Core Concepts

### Molecules

Molecules are the fundamental data entities in AchemDB. Each molecule has:

- **ID**: Unique identifier
- **Species**: The type/class of the molecule (e.g., "Event", "Suspicion", "Alert")
- **Payload**: Arbitrary key-value data
- **Energy**: A numeric value that can decay over time
- **Stability**: Affects how the molecule behaves in reactions
- **Tags**: Optional string tags for categorization
- **Timestamps**: `CreatedAt` and `LastTouchedAt` for lifecycle tracking

### Species

Species define the types of molecules in your system. They're registered in a **Schema** along with their descriptions and metadata.

### Reactions

Reactions define how molecules transform. Each reaction implements:

- **InputPattern**: Determines which molecules the reaction applies to
- **Rate**: Probability (0.0-1.0) that the reaction occurs
- **Apply**: The transformation logic that produces a `ReactionEffect`

A `ReactionEffect` can:

- Consume molecules (specify IDs in `ConsumedIDs`)
- Update molecules (specify changes in `Changes`)
- Create new molecules (add to `NewMolecules`)
- Perform additional operations (via `AdditionalOps`)

### Environment

The **Environment** manages all molecules and applies reactions over discrete time steps. Each `Step()`:

1. Increments the environment time
2. Iterates through all molecules
3. Applies matching reactions probabilistically
4. Updates the molecule state based on reaction effects

## Example: Security Alert System

The included demo shows how to build a security alert system:

```go
schema := achem.NewSchema("security-alerts").WithSpecies(
    achem.Species{
        Name:        "Event",
        Description: "Raw security/ops events",
    },
    achem.Species{
        Name:        "Suspicion",
        Description: "Suspicious entities (IP/user/etc.)",
    },
    achem.Species{
        Name:        "Alert",
        Description: "Alerts generated by the system",
    },
).WithReactions(
    NewLoginFailureToSuspicionReaction(),
    NewSuspicionToAlertReaction(),
    NewDecayReaction(),
)

env := achem.NewEnvironment(schema)

// Insert login failure events
for i := 0; i < 5; i++ {
    env.Insert(achem.NewMolecule("Event", map[string]any{
        "type": "login_failed",
        "ip":   "1.2.3.4",
    }, 0))
}

// Run simulation
for range 100 {
    env.Step()
}
```

### How It Works

1. **LoginFailureToSuspicionReaction**: Converts `Event` molecules with `type="login_failed"` into `Suspicion` molecules
2. **SuspicionToAlertReaction**: When 3+ `Suspicion` molecules exist for the same IP, creates an `Alert` molecule
3. **DecayReaction**: Gradually reduces energy of `Suspicion` and `Alert` molecules; removes them when energy reaches zero

## Usage

### Creating a Schema

```go
schema := achem.NewSchema("my-system").WithSpecies(
    achem.Species{
        Name:        "MySpecies",
        Description: "Description of this species",
    },
).WithReactions(
    myReaction1,
    myReaction2,
)
```

### Implementing a Reaction

```go
type MyReaction struct {
    baseRate float64
}

func (r *MyReaction) ID() string   { return "my_reaction" }
func (r *MyReaction) Name() string { return "My Reaction" }
func (r *MyReaction) Rate() float64 { return r.baseRate }

func (r *MyReaction) InputPattern(m achem.Molecule) bool {
    return m.Species == "MySpecies"
}

func (r *MyReaction) Apply(m achem.Molecule, env achem.EnvView, ctx achem.ReactionContext) achem.ReactionEffect {
    // Example: Transform molecule (consume input, create output)
    newMol := achem.NewMolecule("NewSpecies", map[string]any{
        "source": m.ID,
    }, ctx.EnvTime)
    
    return achem.ReactionEffect{
        ConsumedIDs:  []achem.MoleculeID{m.ID}, // Consume the input molecule
        NewMolecules: []achem.Molecule{newMol}, // Create new molecules
    }
    
    // Alternative: Update molecule without consuming
    // updated := m
    // updated.Energy += 1.0
    // updated.LastTouchedAt = ctx.EnvTime
    // return achem.ReactionEffect{
    //     ConsumedIDs: []achem.MoleculeID{},
    //     Changes: []achem.MoleculeChange{
    //         {ID: m.ID, Updated: &updated},
    //     },
    // }
}
```

### Working with the Environment

```go
env := achem.NewEnvironment(schema)

// Insert molecules
molecule := achem.NewMolecule("MySpecies", map[string]any{
    "key": "value",
}, env.now())
env.Insert(molecule)

// Run simulation steps
for i := 0; i < 100; i++ {
    env.Step()
}

// Query molecules
allMolecules := env.AllMolecules()
```

## Architecture

```
internal/achem/
├── molecule.go    # Molecule data structure
├── species.go     # Species definitions
├── schema.go      # Schema management
├── reaction.go    # Reaction interface
├── environment.go # Environment and simulation engine
└── utils.go       # Utility functions

cmd/demo/
├── main.go                    # Example application
├── login_failure_reaction.go  # Event → Suspicion reaction
├── suspicion_alert_reaction.go # Suspicion → Alert reaction
└── decay_reaction.go          # Energy decay reaction
```

## Requirements

- Go 1.25.4 or later

## Installation

```bash
go get github.com/daniacca/achemdb
```

## Running the Demo

```bash
cd cmd/demo
go run .
```

This will simulate a security alert system and output the final counts of Events, Suspicions, and Alerts.

## Design Philosophy

AchemDB embraces a **reactive, chemistry-inspired** model where:

- Data flows through transformations rather than being queried
- Reactions are declarative and composable
- The system evolves over time through discrete steps
- Probabilistic rates add natural variability
- Molecules have lifecycle properties (energy, stability) that affect behavior

This approach is particularly powerful for systems that need to:

- Detect patterns across multiple data points
- Evolve state over time
- Handle complex, multi-stage transformations
- Model systems with natural decay or aging

## Acknowledgments

This work was inspired by the book **"Dalle Stelle alla cellula"** by [Francesco Cacciante](https://x.com/cacciadiscienza). The core concept of AchemDB draws from his beautiful explanation about proto-metabolism and what could have happened inside a "crateric lake" in primordial planet Earth - where simple molecules interacted through reactions, gradually evolving into more complex structures. This biological and chemical inspiration provided the foundation for thinking about data processing as a reactive, evolving system rather than static storage and retrieval.
